{"ast":null,"code":"//\n//      This is the REDUX \"duck\" format file.\n//\n//      This file contains all the constants, reducers, and action creators in one file\n//      rather than spread them out among multiple directories and files.\n//\n// Action Types\n// Types are listened for within the reducer switch whenever an action is fired off.\n// The action is sent to the reducer with a type, and when that type matches the type within the a case of the switch,\n// some sort of data manipulation is fired off.\n//\n// They are defined as all upper-case constants and may be exported if needed elsewhere.\nconst BLOCKCHAIN_INITIALIZED = \"BLOCKCHAIN_INITIALIZED\";\nconst ZOMBIE_COUNT = \"ZOMBIE_COUNT\"; //  Actions and Action Creator Functions\n//\n// Actions are simple javascript objects that at least contain a type, and may also contain data that can be sent to the reducer.\n// When the user clicks on something that has an effect on the state of an app, an action creator sends an action to the reducer\n// where the data manipulation happens.\n//\n// An action typically looks like this:   { type: ADD_ITEM, item: 'Adding this item' }\n//\n// Action creators are the functions that create actions and send them to the reducer.\n// They usually return an action, sometimes can dispatch multiple actions (with the help of middleware like thunk),\n// or can begin asynchronous events like API calls.\n\nexport function blockchainInitialized(data) {\n  return {\n    type: BLOCKCHAIN_INITIALIZED,\n    payload: data\n  };\n} //\n//  define the initial state for the store\n//\n\nconst initialState = {\n  CZ: {},\n  // contract instance with methods, etc.\n  signer: null,\n  userAddress: 0x0,\n  provider: null,\n  userZombieCount: 0,\n  totalZombieCount: 0\n}; // Reducers\n//\n// The reducer is typically the only thing that touches the store.\n// It only deals within a particular part of the store, initialized as initialState.\n// It's a pure switch statement that does not directly change the state because state is immutable.\n// That means you cannot use a method like .pop or .push that manipulates the array it's called on.\n// Instead we create a now store from the old store and any information we want to put in to it.\n// All reducers have a default case that just returns state.\n//\n// In this case, note that it is the default export.\n\nexport default function reducer(state = initialState, action) {\n  console.log(\"reducer\", action);\n\n  switch (action.type) {\n    case BLOCKCHAIN_INITIALIZED:\n      return Object.assign({}, state, {\n        CZ: action.payload.CZ,\n        signer: action.payload.signer,\n        userAddress: action.payload.userAddress,\n        provider: action.payload.provider,\n        userZombieCount: action.payload.userZombieCount\n      });\n\n    case ZOMBIE_COUNT:\n      console.log(\"my reducer zombie count\", state);\n      return Object.assign({}, state, {\n        totalZombieCount: action.payload.totalZombieCount,\n        userZombieCount: action.payload.userZombieCount\n      });\n\n    default:\n      return state;\n  }\n}","map":{"version":3,"sources":["/Users/jgersch/CSU Classes/CS458 Spring 2021/Projects/CryptoZombiesGame2021/zombiedapp/src/redux/modules/czAppDuck.js"],"names":["BLOCKCHAIN_INITIALIZED","ZOMBIE_COUNT","blockchainInitialized","data","type","payload","initialState","CZ","signer","userAddress","provider","userZombieCount","totalZombieCount","reducer","state","action","console","log","Object","assign"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA,MAAMA,sBAAsB,GAAG,wBAA/B;AACA,MAAMC,YAAY,GAAG,cAArB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,OAAO,SAASC,qBAAT,CAA+BC,IAA/B,EAAqC;AAC1C,SAAO;AACLC,IAAAA,IAAI,EAAEJ,sBADD;AAELK,IAAAA,OAAO,EAAEF;AAFJ,GAAP;AAID,C,CAED;AACA;AACA;;AAEA,MAAMG,YAAY,GAAG;AACjBC,EAAAA,EAAE,EAAE,EADa;AACT;AACRC,EAAAA,MAAM,EAAE,IAFS;AAGjBC,EAAAA,WAAW,EAAE,GAHI;AAIjBC,EAAAA,QAAQ,EAAE,IAJO;AAKjBC,EAAAA,eAAe,EAAE,CALA;AAMjBC,EAAAA,gBAAgB,EAAE;AAND,CAArB,C,CASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAASC,OAAT,CAAiBC,KAAK,GAAGR,YAAzB,EAAuCS,MAAvC,EAA+C;AAC5DC,EAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBF,MAAvB;;AACA,UAAQA,MAAM,CAACX,IAAf;AAEE,SAAKJ,sBAAL;AACI,aAAOkB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAlB,EAAyB;AAC5BP,QAAAA,EAAE,EAAEQ,MAAM,CAACV,OAAP,CAAeE,EADS;AAE5BC,QAAAA,MAAM,EAAEO,MAAM,CAACV,OAAP,CAAeG,MAFK;AAG5BC,QAAAA,WAAW,EAAEM,MAAM,CAACV,OAAP,CAAeI,WAHA;AAI5BC,QAAAA,QAAQ,EAAEK,MAAM,CAACV,OAAP,CAAeK,QAJG;AAK5BC,QAAAA,eAAe,EAAEI,MAAM,CAACV,OAAP,CAAeM;AALJ,OAAzB,CAAP;;AAQJ,SAAKV,YAAL;AACIe,MAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ,EAAuCH,KAAvC;AACF,aAAOI,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAlB,EAAyB;AAC9BF,QAAAA,gBAAgB,EAAEG,MAAM,CAACV,OAAP,CAAeO,gBADH;AAE9BD,QAAAA,eAAe,EAAEI,MAAM,CAACV,OAAP,CAAeM;AAFF,OAAzB,CAAP;;AAKF;AACE,aAAOG,KAAP;AAnBJ;AAqBD","sourcesContent":["//\n//      This is the REDUX \"duck\" format file.\n//\n//      This file contains all the constants, reducers, and action creators in one file\n//      rather than spread them out among multiple directories and files.\n//\n\n// Action Types\n\n// Types are listened for within the reducer switch whenever an action is fired off.\n// The action is sent to the reducer with a type, and when that type matches the type within the a case of the switch,\n// some sort of data manipulation is fired off.\n//\n// They are defined as all upper-case constants and may be exported if needed elsewhere.\n\nconst BLOCKCHAIN_INITIALIZED = \"BLOCKCHAIN_INITIALIZED\";\nconst ZOMBIE_COUNT = \"ZOMBIE_COUNT\";\n\n//  Actions and Action Creator Functions\n//\n// Actions are simple javascript objects that at least contain a type, and may also contain data that can be sent to the reducer.\n// When the user clicks on something that has an effect on the state of an app, an action creator sends an action to the reducer\n// where the data manipulation happens.\n//\n// An action typically looks like this:   { type: ADD_ITEM, item: 'Adding this item' }\n//\n// Action creators are the functions that create actions and send them to the reducer.\n// They usually return an action, sometimes can dispatch multiple actions (with the help of middleware like thunk),\n// or can begin asynchronous events like API calls.\n\n\nexport function blockchainInitialized(data) {\n  return {\n    type: BLOCKCHAIN_INITIALIZED,\n    payload: data\n  };\n}\n\n//\n//  define the initial state for the store\n//\n\nconst initialState = {\n    CZ: {}, // contract instance with methods, etc.\n    signer: null,\n    userAddress: 0x0,\n    provider: null,\n    userZombieCount: 0,\n    totalZombieCount: 0\n};\n\n// Reducers\n//\n// The reducer is typically the only thing that touches the store.\n// It only deals within a particular part of the store, initialized as initialState.\n// It's a pure switch statement that does not directly change the state because state is immutable.\n// That means you cannot use a method like .pop or .push that manipulates the array it's called on.\n// Instead we create a now store from the old store and any information we want to put in to it.\n// All reducers have a default case that just returns state.\n//\n// In this case, note that it is the default export.\n\nexport default function reducer(state = initialState, action) {\n  console.log(\"reducer\", action);\n  switch (action.type) {\n\n    case BLOCKCHAIN_INITIALIZED:\n        return Object.assign({}, state, {\n            CZ: action.payload.CZ,\n            signer: action.payload.signer,\n            userAddress: action.payload.userAddress,\n            provider: action.payload.provider,\n            userZombieCount: action.payload.userZombieCount\n        });\n\n    case ZOMBIE_COUNT:\n        console.log(\"my reducer zombie count\", state);\n      return Object.assign({}, state, {\n        totalZombieCount: action.payload.totalZombieCount,\n        userZombieCount: action.payload.userZombieCount\n      });\n\n    default:\n      return state;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}